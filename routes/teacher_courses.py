# backend/routes/teacher_courses.py - FIXED VERSION

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, text
from typing import List, Dict, Optional
from pydantic import BaseModel
from config.database import get_db
from config.security import get_current_user
from models import Course, CourseEnrollment, User, Quiz
import logging

router = APIRouter(prefix="/api/teacher/courses", tags=["teacher-courses"])

logger = logging.getLogger(__name__)

# Pydantic models
class CourseCreate(BaseModel):
    course_name: str
    description: Optional[str] = None
    board: str
    class_level: str
    subject: str
    max_students: Optional[int] = 100

class CourseUpdate(BaseModel):
    course_name: Optional[str] = None
    description: Optional[str] = None
    is_active: Optional[bool] = None
    max_students: Optional[int] = None

class CourseResponse(BaseModel):
    id: str
    course_name: str
    course_code: str
    description: Optional[str]
    board: str
    class_level: str
    subject: str
    is_active: bool
    max_students: int
    current_students: int
    total_quizzes: int
    created_at: str
    updated_at: Optional[str]

class StudentResponse(BaseModel):
    id: str
    full_name: Optional[str]
    email: str
    status: str
    enrolled_at: str
    total_quizzes_taken: int
    average_score: float

def check_teacher_permission(user: Dict):
    """Check if user is a teacher"""
    # Uncomment when role-based auth is implemented
    if user.get('role') != 'teacher':
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only teachers can access this endpoint"
        )
    # return True

@router.post("/", response_model=CourseResponse)
async def create_course(
    course_data: CourseCreate,
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new course"""
    try:
        check_teacher_permission(current_user)
        
        # REMOVED: Manual course code generation (handled by DB trigger)
        # Create course - course_code will be auto-generated by database trigger
        new_course = Course(
            teacher_id=current_user['id'],
            course_name=course_data.course_name,
            # course_code is NOT set here - let DB trigger handle it
            description=course_data.description,
            board=course_data.board,
            class_level=course_data.class_level,
            subject=course_data.subject,
            max_students=course_data.max_students
        )
        
        db.add(new_course)
        db.commit()
        db.refresh(new_course)
        
        # ENHANCED: Use optimized query with joins instead of separate queries
        stats_query = text("""
            SELECT 
                COALESCE(student_count, 0) as current_students,
                COALESCE(quiz_count, 0) as total_quizzes
            FROM (
                SELECT 
                    (SELECT COUNT(*) FROM course_enrollments WHERE course_id = :course_id AND status = 'active') as student_count,
                    (SELECT COUNT(*) FROM quizzes WHERE course_id = :course_id) as quiz_count
            ) stats
        """)
        
        stats = db.execute(stats_query, {"course_id": str(new_course.id)}).fetchone()
        
        return CourseResponse(
            id=str(new_course.id),
            course_name=new_course.course_name,
            course_code=new_course.course_code,  # This will be populated by DB trigger
            description=new_course.description,
            board=new_course.board,
            class_level=new_course.class_level,
            subject=new_course.subject,
            is_active=new_course.is_active,
            max_students=new_course.max_students,
            current_students=stats.current_students if stats else 0,
            total_quizzes=stats.total_quizzes if stats else 0,
            created_at=new_course.created_at.isoformat(),
            updated_at=new_course.updated_at.isoformat() if new_course.updated_at else None
        )
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error creating course: {str(e)}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating course: {str(e)}"
        )

@router.get("/", response_model=List[CourseResponse])
async def get_teacher_courses(
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all courses for the current teacher"""
    try:
        check_teacher_permission(current_user)
        
        # ENHANCED: More efficient query leveraging database indexes
        query = text("""
            SELECT 
                c.id,
                c.course_name,
                c.course_code,
                c.description,
                c.board,
                c.class_level,
                c.subject,
                c.is_active,
                c.max_students,
                c.created_at,
                c.updated_at,
                COALESCE(student_counts.student_count, 0) as current_students,
                COALESCE(quiz_counts.quiz_count, 0) as total_quizzes
            FROM courses c
            LEFT JOIN (
                SELECT course_id, COUNT(*) as student_count
                FROM course_enrollments
                WHERE status = 'active'
                GROUP BY course_id
            ) student_counts ON c.id = student_counts.course_id
            LEFT JOIN (
                SELECT course_id, COUNT(*) as quiz_count
                FROM quizzes
                GROUP BY course_id
            ) quiz_counts ON c.id = quiz_counts.course_id
            WHERE c.teacher_id = :teacher_id
            ORDER BY c.created_at DESC
        """)
        
        courses = db.execute(query, {"teacher_id": current_user['id']}).fetchall()
        
        return [
            CourseResponse(
                id=str(course.id),
                course_name=course.course_name,
                course_code=course.course_code,
                description=course.description,
                board=course.board,
                class_level=course.class_level,
                subject=course.subject,
                is_active=course.is_active,
                max_students=course.max_students,
                current_students=course.current_students,
                total_quizzes=course.total_quizzes,
                created_at=course.created_at.isoformat(),
                updated_at=course.updated_at.isoformat() if course.updated_at else None
            )
            for course in courses
        ]
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error fetching courses: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching courses: {str(e)}"
        )

@router.get("/{course_id}", response_model=CourseResponse)
async def get_course_details(
    course_id: str,
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get details of a specific course"""
    try:
        check_teacher_permission(current_user)
        
        # ENHANCED: Single query with all needed data (RLS-compatible)
        query = text("""
            SELECT 
                c.id,
                c.course_name,
                c.course_code,
                c.description,
                c.board,
                c.class_level,
                c.subject,
                c.is_active,
                c.max_students,
                c.created_at,
                c.updated_at,
                (SELECT COUNT(*) FROM course_enrollments WHERE course_id = c.id AND status = 'active') as current_students,
                (SELECT COUNT(*) FROM quizzes WHERE course_id = c.id) as total_quizzes
            FROM courses c
            WHERE c.id = :course_id AND c.teacher_id = :teacher_id
        """)
        
        course = db.execute(query, {
            "course_id": course_id, 
            "teacher_id": current_user['id']
        }).fetchone()
        
        if not course:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Course not found"
            )
        
        return CourseResponse(
            id=str(course.id),
            course_name=course.course_name,
            course_code=course.course_code,
            description=course.description,
            board=course.board,
            class_level=course.class_level,
            subject=course.subject,
            is_active=course.is_active,
            max_students=course.max_students,
            current_students=course.current_students,
            total_quizzes=course.total_quizzes,
            created_at=course.created_at.isoformat(),
            updated_at=course.updated_at.isoformat() if course.updated_at else None
        )
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error fetching course details: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching course details: {str(e)}"
        )

@router.put("/{course_id}", response_model=CourseResponse)
async def update_course(
    course_id: str,
    course_data: CourseUpdate,
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a course"""
    try:
        check_teacher_permission(current_user)
        
        # ENHANCED: Verify ownership and update in single transaction
        course = db.query(Course).filter(
            Course.id == course_id,
            Course.teacher_id == current_user['id']
        ).first()
        
        if not course:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Course not found"
            )
        
        # Update only provided fields
        update_data = course_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(course, field, value)
        
        db.commit()
        db.refresh(course)
        
        # Get updated stats efficiently
        stats_query = text("""
            SELECT 
                (SELECT COUNT(*) FROM course_enrollments WHERE course_id = :course_id AND status = 'active') as current_students,
                (SELECT COUNT(*) FROM quizzes WHERE course_id = :course_id) as total_quizzes
        """)
        
        stats = db.execute(stats_query, {"course_id": course_id}).fetchone()
        
        return CourseResponse(
            id=str(course.id),
            course_name=course.course_name,
            course_code=course.course_code,
            description=course.description,
            board=course.board,
            class_level=course.class_level,
            subject=course.subject,
            is_active=course.is_active,
            max_students=course.max_students,
            current_students=stats.current_students if stats else 0,
            total_quizzes=stats.total_quizzes if stats else 0,
            created_at=course.created_at.isoformat(),
            updated_at=course.updated_at.isoformat() if course.updated_at else None
        )
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error updating course: {str(e)}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating course: {str(e)}"
        )

@router.delete("/{course_id}")
async def delete_course(
    course_id: str,
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a course"""
    try:
        check_teacher_permission(current_user)
        
        # ENHANCED: Check ownership and dependencies in single query
        check_query = text("""
            SELECT 
                c.id,
                (SELECT COUNT(*) FROM course_enrollments WHERE course_id = c.id) as enrollment_count,
                (SELECT COUNT(*) FROM quizzes WHERE course_id = c.id) as quiz_count
            FROM courses c
            WHERE c.id = :course_id AND c.teacher_id = :teacher_id
        """)
        
        result = db.execute(check_query, {
            "course_id": course_id,
            "teacher_id": current_user['id']
        }).fetchone()
        
        if not result:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Course not found"
            )
        
        # ENHANCED: Check for dependencies before deletion
        if result.enrollment_count > 0 or result.quiz_count > 0:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Cannot delete course with existing enrollments or quizzes"
            )
        
        # Safe to delete
        course = db.query(Course).filter(Course.id == course_id).first()
        db.delete(course)
        db.commit()
        
        return {"message": "Course deleted successfully"}
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error deleting course: {str(e)}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting course: {str(e)}"
        )

@router.get("/{course_id}/students", response_model=List[StudentResponse])
async def get_course_students(
    course_id: str,
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all students enrolled in a course"""
    try:
        check_teacher_permission(current_user)
        
        # ENHANCED: Verify ownership first, then get students
        course = db.query(Course).filter(
            Course.id == course_id,
            Course.teacher_id == current_user['id']
        ).first()
        
        if not course:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Course not found"
            )
        
        # Get students with enrollment details (leveraging indexes)
        query = text("""
            SELECT 
                u.id,
                u.full_name,
                u.email,
                ce.status,
                ce.enrolled_at,
                ce.total_quizzes_taken,
                ce.average_score
            FROM course_enrollments ce
            JOIN profiles u ON ce.student_id = u.id
            WHERE ce.course_id = :course_id
            ORDER BY ce.enrolled_at DESC
        """)
        
        students = db.execute(query, {"course_id": course_id}).fetchall()
        
        return [
            StudentResponse(
                id=str(student.id),
                full_name=student.full_name,
                email=student.email,
                status=student.status,
                enrolled_at=student.enrolled_at.isoformat(),
                total_quizzes_taken=student.total_quizzes_taken,
                average_score=student.average_score
            )
            for student in students
        ]
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error fetching course students: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching course students: {str(e)}"
        )

@router.post("/{course_id}/remove-student/{student_id}")
async def remove_student(
    course_id: str,
    student_id: str,
    current_user: Dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove a student from a course"""
    try:
        check_teacher_permission(current_user)
        
        # ENHANCED: Verify course ownership and enrollment in single query
        verify_query = text("""
            SELECT ce.id
            FROM course_enrollments ce
            JOIN courses c ON ce.course_id = c.id
            WHERE c.id = :course_id 
              AND c.teacher_id = :teacher_id
              AND ce.student_id = :student_id
        """)
        
        enrollment = db.execute(verify_query, {
            "course_id": course_id,
            "teacher_id": current_user['id'],
            "student_id": student_id
        }).fetchone()
        
        if not enrollment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Student not found in your course"
            )
        
        # Remove enrollment
        delete_query = text("""
            DELETE FROM course_enrollments 
            WHERE course_id = :course_id AND student_id = :student_id
        """)
        
        db.execute(delete_query, {
            "course_id": course_id,
            "student_id": student_id
        })
        db.commit()
        
        return {"message": "Student removed from course successfully"}
        
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error removing student: {str(e)}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error removing student: {str(e)}"
        )